別プロジェクトで作成してもBundle Identifierが同じであれば同じアプリとして申請できる。

1/24
・静的型付き言語
　→コンパイル時など実行前の段階で、変数や定数の型(type)の情報を決定するプログラミング言語。
・swiftではnilを代入できない。
　→代入するときは、nilを許容するOptional<Wrapped>型を使用。
・ジェネリクス
　→引数の方は抽象的なものとなっており、さまざまなかたの引数を渡せます。
・引数の _ は名前がない引数ということを表す。
・命名規則
　→単語ごとに大文字にする(ロワーキャメルケース)
　→型はアッパーキャメルけーす(大文字のアルファベットをはじまりとする。)


1/25
・型アノテーション
　→:Int　宣言時に型を記述している所
・型の確認方法
　→type(of: a) もしくは　コマンド＋コントロール＋？など。
・リテラル
　→１や"abc"などの値をプログラムに直接表記する書式。
・多くの方にはプロパティやメソッドが定義されている。
　→String型には文字数を表すcountプロパティや、指定した文字ではじまるかを判定するstarts(with:)メソッドが定義されている。
・型エイリアス
　→type alias CLLocationDegrees = Double
・import Foundation
　→C言語のmath.h相当の数学関数が用意されている。また、円周率はFloat型のスタティックプロパティpiが定義されている。
・複数行文字列表示
　→""" 表示したい文字 """
・SwiftはSstring同士の結合は+で行える。
・Any型(任意の型を表す)
・tuple型(複数の型をまとめる型)


1/26
・サブスクリプト
　→コレクションにインデックス(添字)を与え、そのインデックスに位置する要素の取得や書き換えを行う機能。
・コレクション
　→配列(Array<Element>型),辞書(Dictionary<Key, Value>型), 範囲(Range<Bound>型), 文字列(String型)
・map(_:)メソッド
　→要素を変換する。
　　let array = [1,2,3,4,5,6]
　　let doubled = array.map({element in String(element)})
　　converted // ["1", "2", "3", "4", "5", "6"]


1/27
・If-let文
　→Optional<Wrapped>型の値が存在する場合のみ{}内の文を実行。
・guard文
　→条件不成立時に早期退出する分岐
・guard-let文
→if-letと同じだが、guard-letだとスコープ外でも変数を利用可能。
・Whereキーワード
　→ケースにマッチする条件を追加できる。
・C言語などではケースを実行した後後続のケースが実行されるが、Swiftではfallthrough分によって明示しない限り、このような挙動にはなりません。


2/7
・Observer
→ある人が何かしたら、そのことを知りたい人たちに教えてあげる処理方式のこと。
・Sequence
→順番に並んだデータや手続きのこと、または順番に並んだそれらを並んだ順番通りに随時処理していく方式のことを指す。
・ReactiveX
→Observerパターンが使われる非同期処理やUIのイベント処理などを、意図した手順で処理できるSwquenceな形で、かつ誰にも理解しやすい宣言的な書き方で、スレッドの動機制御やリソースの排他制御や軟化の辛い処理を自分で書くことなく実装することのできるライブラリ。


7/4
戻り値が定義されている関数を呼び出す場合、通常は戻り値を変数や定数に代入します。Playgroound以外の環境では、戻り値の代入を省略するとコンパイラが警告を出します。戻り値が不要な場合は_への代入によって明治的に戻り値を無視することでこの警告を抑制できます。
もしくは@discardableResultを記述することでもこの警告を抑制できる。

デフォルト引数
→引数に= ""と代入の形で書く。
この場合、関数を呼び出すときは引数を指定しなくて良い。

インアウト引数
呼び出し元では&をつける。呼び出し先ではinoutキーワードを。すると呼び出しもとの変数も変更が反映される。

可変長引数(任意の個数の値を受け取る引数。)
→...　呼び出し先の引数の型のところにつける。

関数がreturの処理のみの場合はreturnを省略できる。

クロージャは引数と戻り値のかたを省略できることがある。

簡略引数名
→$0を使用することでfilterなどの時に、$1、$2等と配列等の値を比較するときに使える。

Escaping属性 非同期的に実行されるクロージャ
→関数に引数として渡されたクロージャが関数のスコープ外で保持される可能性があることを示す属性です。

Autoclosure属性　クロージャを用いた遅延評価
引数をクロージャで包むことで遅延評価を実現するための属性。
第二引数をクロージャにすることで必要になるまで評価を遅らせることができるようになりました。これを遅延評価という。
Autoclosure属性は第二引数を暗黙的にクロージャで包む処理をしてくれる。

トレイリングクロージャ　引数のクロージャを()の外に記述する記法
関数の最後の引数がクロージャの場合にクロージャを()の外に書くことができる記法。



7/5
レイジーストアドプロパティ
アクセス時まで初期化を遅延させるプロパティ。インスタンス生成時には初期化されない
Lazy var lazyVale: Int = {}

Varキーワードにつづけてプロパティ名と型名を指定し、{}内にgetキーワードでゲッタをsetキーワードでセッタを指定します。ゲッタはプロパティの値を返す処理、セッタはプロパティの値を更新する処理です。
値を代入する処理を行うとsetの処理が走り、値を取得する処理を行うとgetの処理が走る。　


10/16
スプライトキットでのテクスチャアニメーションの画像はスプライトアトラスという方法で表示させる。
マネージャクラスなどを使う場合は、クラス内でスタティックインスタンスを作成し、それを外部から使用する。

10/30
オブザーバー→現代ではdelegateを使用。
Observerパターンの実装をC#風にdelegateを使用して行った例です。
delegateを使うと、observerとobservableインターフェイスを使った例よりも少ないコードで記述することが出来ます。登録されたobserverの管理、Notify()、Update()がなくなります。ただし、欠点としては一見してobservableかどうかわからなくなってしまったことです。
Observerパターンとは、
1. あるクラスの値が変更された (observable class)
2. 別のクラスでその変更を認識したい (observer)
というときに使います。

11/27
・StructやEnumのような値型では、自身の値を変更する場合には、メソッドの宣言にmutatingキーワードをつける必要があります。
・IntやStructは値型で別の変数に代入しても別々の変数として処理される。
　Classは参照型、別の変数に代入しても同一のものとして処理される。
・ストアドプロパティは、特定のクラスや構造体のインスタンスの一部として、シンプルな形式で保存される定数または変数のことで　　
　す。ストアドプロパティは、（var キーワードで）変数のストアドプロパティ、または（let キーワードで）定数のストアドプロパ　　　　
　ティのどちらにでもすることができます。
・構造体の場合、イニシャライザを自分で定義しない場合、自動的にメンバワイズイニシャライザ(memberwise initializer)が内
　部的に用意されます。(classでは使えない？)
・コンピューテッドプロパティ→値を保持せず、算出した値を返します。
・スタティックプロパティ→staticキーワードがついたプロパティ(インスタンスからプロパティを使うことはできません。)
・クラスプロパティ→classキーワードがついたプロパティ(クラスに紐付くプロパティを、クラスプロパティといいます。)
・コンビニエンスイニシャライザ→他のイニシャライザに処理を委譲（delegate）することができます。つまりイニシャライザの中で別
　のイニシャライザを呼ぶことが出来ます。
・SwiftはARC方式(Automatic Reference Countingの略で、参照カウントの増減を自動的にやってくれる仕組み)
・デイニシャライザ→deinit {}で破棄される時に処理を行える。
・参照型の比較は、参照先の値同士の比較であれば==演算子、参照先自体の比較は===演算子で行う。
　let a = SomeClass()
  Let b = SomeClass()
  Let c = a
  a == b // true
  a === b // false
  A === c // true
・enumもイニシャライザを使用してインスタンスを生成可能。ストアドプロパティを持つことはできない。
・enum連想値→
  Enum Color { 
       Case rgb(Float, Float, Float)
       Case cmyk(Float, Float, Float, Float)
  }
  Let Rob = Color.rgb(0.0, 0.33, 0.66)
  Let cmyk = Color.cmyk(0.0, 0.33 0.66, 0.99)
　※全てのcaseに適用したい場合は、
  Enum Color: CaseIterable { case rgb, case    }
　以下のように自分で記述することも可能。static var allCases: [Direction1] = [.east, .west, .north, .south]
　enumが連想値を持つ場合は、allCasesを自分で作らないといけない。

